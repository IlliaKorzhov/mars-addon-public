library GameUtils requires Modifiers, Stuns {
	public unit CasterUnit;
	public unit OwnerUnit;
	public unit TargetUnit;
	public real Value;
	public unit AuraOwnerUnit;
	public unit AuraTargetUnit;
	public boolean IsEntered;
	public boolean IsOut;
	public boolean IsActions;
	public boolean IsTransfer;
	public integer ActionsId;
	public integer BuffId;
	public timer BuffStack;

	real EVENT_OVER_HEAL_GET;
	
	//local constants
	constant real TIMER_PERIOD = 0.03125;
	
	public function GetEventOverHeal() -> real {
		return EVENT_OVER_HEAL_GET;
	}

	//Исцеление
	public function HealUnit(unit whichUnit, unit targetUnit, real value) {
		real valueTrue = value * GetUnitModifier(whichUnit, INC_OUT_HEAL) * GetUnitModifier(whichUnit, DEC_OUT_HEAL) * GetUnitModifier(targetUnit, INC_ENTER_HEAL) * GetUnitModifier(targetUnit, DEC_ENTER_HEAL);
		if (valueTrue > 0) {
			CasterUnit = whichUnit;
			TargetUnit = targetUnit;
			Value = valueTrue;
			EVENT_OVER_HEAL_GET = MaxReal(0, valueTrue - (GetUnitMaxLife(targetUnit) - GetUnitState(targetUnit, UNIT_STATE_LIFE)));
			SetUnitState(targetUnit, UNIT_STATE_LIFE, GetUnitState(targetUnit, UNIT_STATE_LIFE) + valueTrue);
			TriggerExecute(gg_trg_HealEvent);
			EVENT_OVER_HEAL_GET = 0;
		}
	}

	//Восстановление маны
	public function RestoreManaUnit(unit whichUnit, unit targetUnit, real value) {
		real valueTrue = value * GetUnitModifier(whichUnit, INC_OUT_MANA) * GetUnitModifier(whichUnit, DEC_OUT_MANA) * GetUnitModifier(targetUnit, INC_ENTER_MANA) * GetUnitModifier(targetUnit, DEC_ENTER_MANA);
		SetUnitState(targetUnit, UNIT_STATE_MANA, GetUnitState(targetUnit, UNIT_STATE_MANA) + valueTrue);
		if (valueTrue > 0) {
			CasterUnit = whichUnit;
			TargetUnit = targetUnit;
			Value = valueTrue;

			TriggerExecute(gg_trg_RestoreEvent);

		}
	}
	
	//Исцеление вампиризмом    
	public function HealUnitLifesteal(unit whichUnit, real value) {
		real valueTrue = value * GetUnitModifier(whichUnit, INC_LIFESTEAL);
		if (value > 0) {
			OwnerUnit = whichUnit;
			Value = valueTrue;
			EVENT_OVER_HEAL_GET = MaxReal(0, value - (GetUnitMaxLife(whichUnit) - GetUnitState(whichUnit, UNIT_STATE_LIFE)));
			SetUnitState(whichUnit, UNIT_STATE_LIFE, GetUnitState(whichUnit, UNIT_STATE_LIFE) + value);
			TriggerExecute(gg_trg_HealLifestealEvent);
			EVENT_OVER_HEAL_GET = 0;
		}
	}
	
	//Создание молнии\\
	
	struct Lightning {
		unit caster, target;
		real time, expire, maxDist, lightningZ, timeZ, expireZ;
		lightning lighting;
		timer tm;
		effect effectCaster, effectTarget;
	
		static method create(unit caster, unit target, string lightningType, string effectCasterModel, string effectCasterAttach, string effectTargetModel, string effectTargetAttach, real duration, real maxDistance, real lightningZ, real decayTime, boolean destroyEffects) -> Lightning {
			Lightning this = Lightning.allocate();
			this.caster = caster;
			this.target = target;
			this.time = 0;
			this.maxDist = maxDistance;
			this.expire = duration;
			this.expireZ = decayTime;
			this.timeZ = 0;
			this.lightningZ = lightningZ;
			
			this.lighting = AddLightningEx(
				lightningType,
				true,
				GetUnitX(caster),
				GetUnitY(caster),
				GetUnitZ(caster) + lightningZ,
				GetUnitX(target),
				GetUnitY(target),
				GetUnitZ(target) + lightningZ
			);
			
			this.effectCaster = AddSpecialEffectTarget(effectCasterModel, caster, effectCasterAttach);
			this.effectTarget = AddSpecialEffectTarget(effectTargetModel, target, effectTargetAttach);
			if (destroyEffects) {
				DestroyEffect(this.effectCaster); this.effectCaster = null;
				DestroyEffect(this.effectTarget); this.effectTarget = null;
			}

			this.tm = CreateTimer();
			SaveHandleDataInt(tm, this);
			TimerStart(this.tm, TIMER_PERIOD, true, function Lightning.callback);
			return this;
		}
		
		method destroy(){
			FlushTimer(this.tm); this.tm = null;
			DestroyLightning(this.lighting); this.lighting = null;
			DestroyEffect(this.effectCaster); this.effectCaster = null;
			DestroyEffect(this.effectTarget); this.effectTarget = null;
			this.caster = null;
			this.target = null;
			this.deallocate();
		}
		
		static method callback(){
			Lightning this = LoadHandleDataInt(GetExpiredTimer());
			real xc, yc, zc, xt, yt, zt;
			
			xc = GetUnitX(this.caster);
			yc = GetUnitY(this.caster);
			zc = GetUnitZ(this.caster) + this.lightningZ;
			xt = GetUnitX(this.target);
			yt = GetUnitY(this.target);
			zt = GetUnitZ(this.target) + this.lightningZ;
			
			MoveLightningEx(this.lighting, true, xc, yc, zc, xt, yt, zt);
			if (this.expire - this.time <= this.expireZ) {
				this.timeZ = this.timeZ + TIMER_PERIOD;
				SetLightningColor(this.lighting, 100, 100, 100, (this.expireZ - this.timeZ)/this.expireZ);
			}
			
			this.time = this.time + TIMER_PERIOD;
			if (
				/*
				!UnitAlive(this.caster)
				||
				!UnitAlive(this.target)
				||
				*/
				this.time >= this.expire
				||
				DistanceBetweenCoords3D(xc, yc, zc, xt, yt, zt) >= this.maxDist
			) {
				this.destroy();
			}
		}
	}
	
	public function CreateUnitLightningTarget(unit caster, unit target, string lightningType, string effectCasterModel, string effectCasterAttach, string effectTargetModel, string effectTargetAttach, real duration, real maxDistance, real lightningZ, real decayTime, boolean destroyEffects) -> integer {
		Lightning current;
		current = Lightning.create(caster, target, lightningType, effectCasterModel, effectCasterAttach, effectTargetModel, effectTargetAttach, duration, maxDistance, lightningZ, decayTime, destroyEffects);
		return current;
	}
	//\\

}
